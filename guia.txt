Roteiro Completo para Minishell (com BÃ´nus)
Vou te passar um roteiro estruturado e progressivo para construir o minishell, jÃ¡ preparando a arquitetura para os bÃ´nus.
Fase 1: Estrutura Base e Setup (Dias 1-2)
1.1 OrganizaÃ§Ã£o do Projeto
minishell/
â”œâ”€â”€ Makefile
â”œâ”€â”€ includes/
â”‚   â””â”€â”€ minishell.h
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.c
â”‚   â”œâ”€â”€ lexer/
â”‚   â”œâ”€â”€ parser/
â”‚   â”œâ”€â”€ expander/
â”‚   â”œâ”€â”€ executor/
â”‚   â”œâ”€â”€ builtins/
â”‚   â”œâ”€â”€ signals/
â”‚   â””â”€â”€ utils/
â””â”€â”€ libft/
```

### 1.2 Estruturas Principais
- **Token**: representa cada elemento (palavra, operador, redirecionamento)
- **AST (Abstract Syntax Tree)**: representa a estrutura do comando
- **Ambiente**: gerencia variÃ¡veis de ambiente e exit status

### 1.3 ConfiguraÃ§Ã£o Inicial
- [ ] Criar Makefile bÃ¡sico
- [ ] Definir estruturas fundamentais no header
- [ ] Implementar loop principal com readline
- [ ] Configurar variÃ¡vel global para sinais

## Fase 2: Lexer - AnÃ¡lise LÃ©xica (Dias 3-5)

### 2.1 TokenizaÃ§Ã£o BÃ¡sica
- [ ] Separar string de entrada em tokens
- [ ] Identificar tipos: WORD, PIPE, REDIR_IN, REDIR_OUT, etc.
- [ ] Criar lista encadeada de tokens

### 2.2 Tratamento de Aspas
- [ ] Detectar aspas simples `'` (sem interpretaÃ§Ã£o)
- [ ] Detectar aspas duplas `"` (interpreta `$`)
- [ ] Validar aspas nÃ£o fechadas (retornar erro)
- [ ] Remover aspas apÃ³s processamento

### 2.3 Tratamento de Caracteres Especiais
- [ ] Identificar operadores: `|`, `<`, `>`, `<<`, `>>`
- [ ] **[BÃ”NUS]** Identificar `&&`, `||`, `(`, `)`
- [ ] Separar operadores de palavras corretamente

## Fase 3: Expander - ExpansÃ£o de VariÃ¡veis (Dias 6-7)

### 3.1 ExpansÃ£o BÃ¡sica
- [ ] Expandir `$VARIABLE` para seus valores
- [ ] Expandir `$?` para exit status
- [ ] NÃ£o expandir dentro de aspas simples
- [ ] Expandir dentro de aspas duplas

### 3.2 Casos Especiais
- [ ] Tratar `$` seguido de caracteres invÃ¡lidos
- [ ] Lidar com variÃ¡veis nÃ£o existentes (expandir para vazio)
- [ ] **[BÃ”NUS]** Preparar para wildcards `*`

## Fase 4: Parser - AnÃ¡lise SintÃ¡tica (Dias 8-11)

### 4.1 ConstruÃ§Ã£o da AST
- [ ] Criar nÃ³s para comandos simples
- [ ] Criar nÃ³s para pipes
- [ ] Criar nÃ³s para redirecionamentos
- [ ] **[BÃ”NUS]** Criar nÃ³s para `&&` e `||`
- [ ] **[BÃ”NUS]** Tratar parÃªnteses e precedÃªncia

### 4.2 Estrutura da AST
```
Tipos de nÃ³s:
- CMD_NODE: comando simples com argumentos
- PIPE_NODE: conecta dois comandos
- REDIR_NODE: redirecionamento
- AND_NODE: operador &&
- OR_NODE: operador ||
- SUBSHELL_NODE: comandos entre parÃªnteses
4.3 ValidaÃ§Ã£o SintÃ¡tica

 Validar sequÃªncias de pipes
 Validar redirecionamentos
 Detectar erros de sintaxe

Fase 5: Executor - ExecuÃ§Ã£o de Comandos (Dias 12-16)
5.1 Comandos Simples

 Buscar executÃ¡vel em PATH
 Executar com execve()
 Usar caminhos relativos/absolutos
 Capturar exit status

5.2 Pipes

 Criar pipes com pipe()
 Fazer fork para cada comando
 Conectar stdin/stdout entre processos
 Esperar todos os processos filhos

5.3 Redirecionamentos

 < redirecionar entrada
 > redirecionar saÃ­da (truncate)
 >> redirecionar saÃ­da (append)
 << heredoc (ler atÃ© delimitador)
 Usar dup2() para redirecionar file descriptors

5.4 ExecuÃ§Ã£o Complexa

 Executar AST recursivamente
 [BÃ”NUS] Implementar && (executar prÃ³ximo se sucesso)
 [BÃ”NUS] Implementar || (executar prÃ³ximo se falha)
 [BÃ”NUS] Respeitar precedÃªncia de parÃªnteses

Fase 6: Builtins (Dias 17-19)
6.1 Implementar cada builtin

 echo com opÃ§Ã£o -n
 cd (mudar diretÃ³rio com chdir())
 pwd (mostrar diretÃ³rio atual)
 export (adicionar variÃ¡vel ao ambiente)
 unset (remover variÃ¡vel do ambiente)
 env (mostrar todas as variÃ¡veis)
 exit (sair do shell com cÃ³digo)

6.2 IntegraÃ§Ã£o

 Executar builtins no processo pai (nÃ£o fazer fork)
 Builtins em pipes devem fazer fork
 Atualizar exit status corretamente

Fase 7: Sinais (Dias 20-21)
7.1 ConfiguraÃ§Ã£o de Sinais

 ctrl-C (SIGINT): novo prompt em modo interativo
 ctrl-D (EOF): sair do shell
 ctrl-\ (SIGQUIT): nÃ£o fazer nada em modo interativo
 Usar apenas uma variÃ¡vel global para armazenar sinal

7.2 Comportamento Diferenciado

 Sinais no prompt
 Sinais durante execuÃ§Ã£o de comandos
 Sinais em heredoc

Fase 8: HistÃ³rico e Readline (Dia 22)

 Adicionar comandos ao histÃ³rico com add_history()
 NÃ£o adicionar comandos vazios
 NÃ£o adicionar comandos ao histÃ³rico em heredoc
 Liberar histÃ³rico ao sair com rl_clear_history()

Fase 9: BÃ´nus - Wildcards (Dias 23-24)
9.1 ExpansÃ£o de *

 Detectar * nos tokens
 Expandir para arquivos do diretÃ³rio atual
 Usar opendir(), readdir(), closedir()
 Ordenar resultados alfabeticamente
 NÃ£o expandir se nÃ£o houver matches (manter *)

Fase 10: Testes e Refinamento (Dias 25-28)
10.1 Testes BÃ¡sicos

 Comandos simples
 Comandos com argumentos
 Pipes mÃºltiplos
 Redirecionamentos combinados
 VariÃ¡veis de ambiente

10.2 Testes de Edge Cases

 Aspas complexas: echo "'$USER'"
 MÃºltiplos espaÃ§os e tabs
 Comandos vazios
 Pipes sem comandos
 Redirecionamentos invÃ¡lidos

10.3 Testes de Sinais

 Ctrl-C durante comando
 Ctrl-D em diferentes momentos
 Ctrl-\ durante execuÃ§Ã£o

10.4 Testes de BÃ´nus

 && e || combinados
 ParÃªnteses aninhados
 Wildcards com padrÃµes complexos

10.5 Memory Leaks

 Usar valgrind em todos os casos
 Liberar tokens, AST, ambiente
 NÃ£o se preocupar com leaks do readline

Dicas Importantes
Ordem de Desenvolvimento

Comece simples: faÃ§a funcionar ls, echo hello, pwd
Adicione complexidade gradualmente: pipes â†’ redirecionamentos â†’ variÃ¡veis
Teste constantemente: compare com bash a cada feature

Debugging

Use printf estratÃ©gicos ou um debugger (gdb/lldb)
Teste cada mÃ³dulo isoladamente
Compare output com bash sempre

Armadilhas Comuns

File descriptors: sempre fechar FDs desnecessÃ¡rios
Fork bombs: cuidado com forks infinitos
Zombies: sempre fazer wait() dos processos filhos
Leaks: liberar memÃ³ria em TODOS os caminhos (incluindo erros)

ComparaÃ§Ã£o com Bash
Para qualquer dÃºvida, teste no bash:
bash# Teste o comportamento esperado
bash-3.2$ echo '$USER'
$USER
bash-3.2$ echo "$USER"
seu_usuario
Timeline Sugerida (4 semanas)

Semana 1: Fases 1-3 (Base, Lexer, Expander)
Semana 2: Fases 4-5 (Parser, Executor bÃ¡sico)
Semana 3: Fases 6-7 (Builtins, Sinais)
Semana 4: Fases 8-10 (HistÃ³rico, BÃ´nus, Testes)


# funÃ§Ãµes
ğŸ§­ I/O e memÃ³ria bÃ¡sica
FunÃ§Ã£o	Para que serve
write, read	comunicaÃ§Ã£o com stdin/stdout/stderr
malloc, free	alocaÃ§Ã£o dinÃ¢mica
printf	saÃ­da formatada
access, open, close, unlink, stat	manipular arquivos e redirecionamentos
dup, dup2, pipe	redirecionamentos e pipes
ğŸ§  Processos
FunÃ§Ã£o	Para que serve
fork	criar processos filhos
execve	executar binÃ¡rios externos (/bin/ls, etc.)
wait, waitpid, wait3, wait4	esperar processos filhos terminarem
exit	encerrar o processo com cÃ³digo de retorno
ğŸ§© Sinais
FunÃ§Ã£o	Para que serve
signal, sigaction, sigemptyset, sigaddset	tratamento de sinais (Ctrl+C, Ctrl+\, etc.)
kill	enviar sinal a um processo
ğŸ§­ Sistema / ambiente
FunÃ§Ã£o	Para que serve
getcwd, chdir	pwd e cd
getenv	pegar variÃ¡veis de ambiente
perror, strerror	mensagens de erro padrÃ£o
ğŸ—‚ DiretÃ³rios
FunÃ§Ã£o	Para que serve
opendir, readdir, closedir	manipular diretÃ³rios (para ls, globbing, etc.)
ğŸ› Terminal / termcap
FunÃ§Ã£o	Para que serve
isatty, ttyname, ttyslot, ioctl	informaÃ§Ãµes do terminal
tcsetattr, tcgetattr	controle de modo canÃ´nico e echo
tgetent, tgetflag, tgetnum, tgetstr, tgoto, tputs	controle de termcap (cursor, cores, etc.)
ğŸ’¬ Readline (interaÃ§Ã£o com o usuÃ¡rio)
FunÃ§Ã£o	Para que serve
readline, add_history, rl_replace_line, rl_on_new_line, rl_redisplay, rl_clear_history	prompt interativo e histÃ³rico

Resumo das FunÃ§Ãµes Permitidas
Deixa eu agrupar por categoria para ficar mais claro:
ğŸ“š Readline (Biblioteca externa)

readline() - LÃª uma linha do usuÃ¡rio com prompt
rl_clear_history() - Limpa o histÃ³rico
rl_on_new_line() - Informa readline que estÃ¡ em nova linha
rl_replace_line() - Substitui linha atual
rl_redisplay() - Redesenha a linha
add_history() - Adiciona comando ao histÃ³rico

ğŸ’¾ MemÃ³ria e I/O BÃ¡sico

malloc(), free() - Alocar/liberar memÃ³ria
write(), read() - Escrever/ler em file descriptors
printf() - Escrever na saÃ­da

ğŸ“ Arquivos e DiretÃ³rios

open(), close() - Abrir/fechar arquivos
access() - Verificar permissÃµes de arquivo
unlink() - Remover arquivo
stat(), lstat(), fstat() - Info sobre arquivos
opendir(), readdir(), closedir() - Ler diretÃ³rios (para wildcards)

ğŸ”€ Processos

fork() - Criar processo filho
wait(), waitpid(), wait3(), wait4() - Esperar processos
execve() - Executar programas
exit() - Sair do programa
kill() - Enviar sinais

ğŸ”Œ Pipes e Redirecionamento

pipe() - Criar pipe
dup(), dup2() - Duplicar file descriptors

ğŸ“¡ Sinais

signal(), sigaction() - Configurar handlers de sinais
sigemptyset(), sigaddset() - Manipular conjuntos de sinais

ğŸŒ Ambiente e DiretÃ³rios

getenv() - Pegar variÃ¡vel de ambiente
getcwd() - Pegar diretÃ³rio atual
chdir() - Mudar diretÃ³rio

ğŸ–¥ï¸ Terminal

isatty() - Verifica se Ã© terminal
ttyname(), ttyslot() - Info do terminal
ioctl() - Controle de I/O
tcsetattr(), tcgetattr() - Configurar terminal
tgetent(), tgetflag(), tgetnum(), tgetstr(), tgoto(), tputs() - Termcap (terminal capabilities)

âš ï¸ Erros

strerror(), perror() - Mensagens de erro



# ast parser

ğŸŒ³ O que Ã© uma AST?

AST significa Abstract Syntax Tree â€” em portuguÃªs, Ã¡rvore sintÃ¡tica abstrata.

Ela Ã© uma estrutura em Ã¡rvore que representa a estrutura lÃ³gica do comando digitado no shell.

ğŸ‘‰ Ou seja, a AST Ã© o "esqueleto" do que o usuÃ¡rio digitou.

ğŸ“– Exemplo prÃ¡tico

UsuÃ¡rio digita:

echo hello | grep h


O lexer transforma em tokens:

[TOKEN_WORD: "echo"] [TOKEN_WORD: "hello"] [TOKEN_PIPE: "|"] [TOKEN_WORD: "grep"] [TOKEN_WORD: "h"]


O parser, por sua vez, interpreta a estrutura:

PIPE
 â”œâ”€â”€ CMD (echo hello)
 â””â”€â”€ CMD (grep h)


ğŸ’¡ Assim, a AST guarda como os comandos estÃ£o conectados, nÃ£o sÃ³ suas palavras.

ğŸ“˜ Outro exemplo: com redirecionamento e operadores
(cat file.txt && echo ok) || echo fail > log.txt


AST simplificada:

OR
 â”œâ”€â”€ AND
 â”‚   â”œâ”€â”€ CMD (cat file.txt)
 â”‚   â””â”€â”€ CMD (echo ok)
 â””â”€â”€ REDIR_OUT
     â”œâ”€â”€ CMD (echo fail)
     â””â”€â”€ FILE (log.txt)

ğŸ§± Por que precisamos da AST no minishell

O minishell nÃ£o executa tokens diretamente.
Ele precisa entender o contexto:

quais comandos formam uma pipeline (|),

quando usar && ou ||,

onde aplicar redirecionamentos (>, <, >>, <<),

e atÃ© os parÃªnteses ((...)) para agrupar.

EntÃ£o o parser monta uma Ã¡rvore sintÃ¡tica abstrata (AST),
e depois o executor percorre essa Ã¡rvore para executar tudo na ordem certa.

âš™ï¸ Como o Parser trabalha

Fluxo geral:

Entrada do usuÃ¡rio (string)
        â†“
      Lexer
        â†“
    Lista de tokens
        â†“
      Parser
        â†“
     AST construÃ­da
        â†“
    Executor (ainda virÃ¡)
        â†“
ExecuÃ§Ã£o real (fork, execve, dup2, etc)

ğŸ” O parser Ã© basicamente uma mÃ¡quina de gramÃ¡tica

Ele lÃª os tokens e aplica regras do tipo:

command          â†’ WORD {WORD}
pipeline         â†’ command {"|" command}
and_or           â†’ pipeline {("&&" | "||") pipeline}
complete_command â†’ and_or


Essas regras vÃ£o definir como os nÃ³s da AST sÃ£o montados.

ğŸ’¬ Em resumo
Conceito	O que faz	Exemplo
Lexer	Divide em tokens	`"echo hello
Parser	Organiza tokens em uma estrutura lÃ³gica (AST)	PIPE â†’ CMD (echo hello), CMD (grep h)
Executor	Percorre a Ã¡rvore e executa	cria pipe(), fork(), execve(), etc

Se quiser, o prÃ³ximo passo Ã© montar o design do parser.c com:

a struct da AST (t_ast),

as principais funÃ§Ãµes (como parse_pipeline(), parse_command() etc.),

e um esquema visual de como elas se encaixam.

ğŸ§± VisÃ£o geral do parser bÃ´nus

O parser vai transformar a lista de tokens (da lexer) em uma Ã¡rvore de execuÃ§Ã£o que o executor pode percorrer.

Ele precisa entender prioridades entre os operadores:

()        â†’ mais forte (resolve primeiro)
<<, <, >, >> â†’ redirecionamentos (ligados a comandos)
|         â†’ pipeline
&&, ||    â†’ operadores lÃ³gicos


Portanto, nossa Ã¡rvore terÃ¡ nÃ­veis de precedÃªncia, e o parser precisa refletir isso.

âš™ï¸ FunÃ§Ãµes principais do parser
FunÃ§Ã£o	FunÃ§Ã£o / Papel	Retorna
t_ast *parse_tokens(t_dlist *tokens);	FunÃ§Ã£o principal do parser	Raiz da AST
t_ast *parse_and_or();	nÃ­vel mais alto (&&, `
t_ast *parse_pipeline();	nÃ­vel mÃ©dio (`	`)
t_ast *parse_command();	nÃ­vel bÃ¡sico (palavras e redirs)	NÃ³ comando
t_ast *parse_subshell();	resolve grupos entre ( e )	NÃ³ subshell

A ordem de chamada (por precedÃªncia) serÃ¡:

parse_and_or()
 â””â”€â”€ parse_pipeline()
      â””â”€â”€ parse_command()
           â””â”€â”€ parse_subshell()

ğŸ” Fluxo lÃ³gico do parser

parse_and_or()

olha se hÃ¡ && ou || e separa a esquerda e a direita.

parse_pipeline()

separa comandos pelo |.

parse_command()

constrÃ³i comandos simples (WORD WORD) e verifica redirecionamentos (<, >, >>, <<).

parse_subshell()

detecta e processa ( â€¦ ) recursivamente.

ğŸš¦ Exemplo visual de funcionamento

Entrada:

(cat file.txt && echo ok) || echo fail > log.txt


Fluxo de parsing:

parse_and_or()
â”‚
â”œâ”€â”€ left: parse_subshell("(cat file.txt && echo ok)")
â”‚   â””â”€â”€ AND
â”‚       â”œâ”€â”€ CMD "cat file.txt"
â”‚       â””â”€â”€ CMD "echo ok"
â”‚
â””â”€â”€ right: parse_command("echo fail > log.txt")
    â””â”€â”€ REDIR_OUT
        â”œâ”€â”€ CMD "echo fail"
        â””â”€â”€ FILE "log.txt"

ğŸ’¬ Resumo da arquitetura
NÃ­vel	Operador	FunÃ§Ã£o responsÃ¡vel	Arquivo sugerido
1	&&, `		`
2	`	`	parse_pipeline()
3	redirs <, >, >>, <<	parse_command()	parse_command.c
4	parÃªnteses ( )	parse_subshell()	parse_subshell.c

ğŸ§± ExplicaÃ§Ã£o da estrutura
Parte	FunÃ§Ã£o
parse_tokens()	Ponto de entrada. Recebe a lista de tokens e chama o nÃ­vel mais alto (parse_and_or).
parse_and_or()	Trata && e `
parse_pipeline()	Trata pipes (`
parse_command()	Trata comandos simples e redirecionamentos.
parse_subshell()	Trata expressÃµes entre ( e ).

As funÃ§Ãµes estÃ£o sÃ³ declaradas, para que o compilador saiba que elas existem â€” mas vamos implementÃ¡-las em arquivos separados logo em seguida.

ğŸ’¡ Importante detalhe tÃ©cnico

O parÃ¢metro:

t_dlist **tokens


Ã© um ponteiro para a lista de tokens, nÃ£o uma cÃ³pia.
Assim cada funÃ§Ã£o pode avanÃ§ar a posiÃ§Ã£o atual na lista conforme consome tokens,
permitindo parsing recursivo sem perder o estado.

#parse utils
ğŸ§  Explicando cada funÃ§Ã£o
ast_new_node()

Cria um novo nÃ³ genÃ©rico.
Isso Ã© usado por todas as funÃ§Ãµes parse_* para montar a Ã¡rvore.

Exemplo de uso:

t_ast *node = ast_new_node(NODE_PIPE, left_cmd, right_cmd);

ast_free()

Libera recursivamente toda a Ã¡rvore.

Libera argv (array de strings),

libera filename,

e depois os filhos left e right.

print_ast()

FunÃ§Ã£o de debug visual, super Ãºtil para validar o parser.
Ela imprime a Ã¡rvore com indentaÃ§Ã£o hierÃ¡rquica.

Exemplo de saÃ­da:

(2)
  (0) CMD: echo hello
  (0) CMD: grep h


onde (2) pode ser NODE_PIPE, e (0) comandos simples.

ğŸ§© PrÃ³ximo passo

Agora que temos:
âœ… parser.c â€” ponto de entrada
âœ… parser_utils.c â€” manipulaÃ§Ã£o de Ã¡rvore

Podemos implementar o primeiro nÃ­vel real de parsing:
o parse_command.c, que lida com comandos simples + redirecionamentos (<, >, >>, <<).

Ã‰ o mais direto e o que jÃ¡ te permite testar o parser com comandos reais antes de lidar com pipes ou &&.

# parse command

âš™ï¸ Explicando o funcionamento

ComeÃ§a criando um nÃ³ de comando (NODE_COMMAND).

Percorre os tokens atÃ© achar algo que nÃ£o seja parte do comando.

Para cada TOKEN_WORD, adiciona no argv.

Para cada redirecionamento (<, >, >>, <<),
cria um nÃ³ de redir (NODE_REDIR_*) com o nome do arquivo.

Retorna a Ã¡rvore final (um comando que pode estar encadeado a redirs).

Exemplo prÃ¡tico

Entrada:

cat < in.txt > out.txt


AST resultante (visual simplificado via print_ast()):

(REDIR_OUT) FILE: out.txt
  (REDIR_IN) FILE: in.txt
    (CMD: cat)

ğŸŒ³ VisÃ£o geral do parser completo (com bÃ´nus)

O parser que acabamos de montar implementa uma gramÃ¡tica hierÃ¡rquica, onde cada funÃ§Ã£o trata um nÃ­vel de precedÃªncia dos operadores.
Ele funciona como uma mini linguagem de programaÃ§Ã£o, com operadores (|, &&, ||), agrupamentos (()), e comandos.

ğŸ§© Hierarquia de precedÃªncia

Ordem de avaliaÃ§Ã£o (da mais forte para a mais fraca):

NÃ­vel	Operadores / ConstruÃ§Ãµes	FunÃ§Ã£o que trata	Tipo de nÃ³ AST
1ï¸âƒ£	Subshells: ( ... )	parse_subshell()	NODE_SUBSHELL
2ï¸âƒ£	Comandos simples + redirecionamentos <, >, >>, <<	parse_command()	NODE_COMMAND, NODE_REDIR_*
3ï¸âƒ£	Pipes: `	`	parse_pipeline()
4ï¸âƒ£	LÃ³gicos: &&, `		`

Esses nÃ­veis sÃ£o chamados de cima para baixo,
ou seja, o parser comeÃ§a no nÃ­vel mais alto (and_or), e desce conforme necessÃ¡rio.

ğŸ” Fluxo completo de parsing

Entrada do usuÃ¡rio:

(cat input.txt && echo ok) || echo fail > out.txt


Etapas:

Lexer â†’ gera tokens:

( cat input.txt && echo ok ) || echo fail > out.txt


Parser (funÃ§Ã£o parse_tokens()) chama:

parse_and_or(&tokens);


que cria o nÃ³ NODE_OR, pois detecta ||.

parse_and_or()

Monta a parte da esquerda com parse_pipeline()

Monta a parte da direita tambÃ©m com parse_pipeline()

Junta tudo num nÃ³ NODE_OR(left, right)

parse_pipeline()

Detecta comandos separados por |

Cada comando Ã© obtido via parse_command()

Cria NODE_PIPE(left, right)

parse_command()

LÃª palavras (TOKEN_WORD) e redirecionamentos (<, >, >>, <<)

Monta comandos simples (argv) e redir encadeados

Exemplo: cat < in.txt > out.txt vira:

NODE_REDIR_OUT
 â”œâ”€â”€ NODE_REDIR_IN
 â”‚    â””â”€â”€ NODE_COMMAND (argv = ["cat"])
 â””â”€â”€ filename = "out.txt"


parse_subshell()

Quando vÃª (, chama recursivamente parse_and_or() para o conteÃºdo.

Espera o fechamento com ).

Exemplo: (cat file && echo ok) vira:

NODE_SUBSHELL
  â””â”€â”€ NODE_AND
      â”œâ”€â”€ NODE_COMMAND(cat file)
      â””â”€â”€ NODE_COMMAND(echo ok)

ğŸ§± Estrutura da Ã¡rvore final (AST)

Para a entrada:

(cat input.txt && echo ok) || echo fail > out.txt


A AST final seria:

NODE_OR
 â”œâ”€â”€ NODE_SUBSHELL
 â”‚    â””â”€â”€ NODE_AND
 â”‚         â”œâ”€â”€ NODE_COMMAND: cat input.txt
 â”‚         â””â”€â”€ NODE_COMMAND: echo ok
 â””â”€â”€ NODE_REDIR_OUT
      â”œâ”€â”€ NODE_COMMAND: echo fail
      â””â”€â”€ FILE: out.txt

âš™ï¸ Como o parser decide o que fazer
parse_tokens()

Ponto de entrada.

Chama parse_and_or().

Verifica se todos os tokens foram consumidos (erro se sobrar algo).

parse_and_or()

Procura por && ou ||.

Se encontrar, separa a expressÃ£o Ã  esquerda e Ã  direita.

Monta um nÃ³ NODE_AND ou NODE_OR.

Exemplo:

echo a && echo b || echo c


vira:

NODE_OR
 â”œâ”€â”€ NODE_AND
 â”‚    â”œâ”€â”€ echo a
 â”‚    â””â”€â”€ echo b
 â””â”€â”€ echo c

parse_pipeline()

Divide comandos conectados por |.

Cada lado do pipe Ã© um comando completo, nÃ£o apenas uma palavra.

Exemplo:

ls -l | grep txt | wc -l


vira:

NODE_PIPE
 â”œâ”€â”€ NODE_PIPE
 â”‚    â”œâ”€â”€ CMD: ls -l
 â”‚    â””â”€â”€ CMD: grep txt
 â””â”€â”€ CMD: wc -l

parse_command()

Junta TOKEN_WORD â†’ argv.

Monta redirecionamentos (<, >, >>, <<).

Pode retornar:

Um simples NODE_COMMAND

Ou uma cadeia de NODE_REDIR_* acima do comando

parse_subshell()

Detecta ( e chama recursivamente parse_and_or().

Espera ) para fechar.

Retorna NODE_SUBSHELL com a Ã¡rvore interna.

Isso Ã© o que dÃ¡ suporte a ( ... ) no bÃ´nus.

ğŸ§  Resumo conceitual
Fase	Entrada	SaÃ­da	Estrutura
Lexer	`"echo hi	cat"`	Lista de tokens
Parser	Tokens	AST	t_ast *root
Executor	AST	Processos / SaÃ­das	execuÃ§Ã£o real
ğŸ§° Dica de ouro para testar

Durante o desenvolvimento, crie uma funÃ§Ã£o de teste simples no main():

int	main(int argc, char **argv, char **envp)
{
	t_shell	shell;
	t_dlist	*tokens;
	t_ast	*ast;
	char	*line;

	init_shell(&shell, envp);
	setup_signals();

	while (1)
	{
		line = readline("mini> ");
		if (!line)
			break;
		tokens = lexer(line);
		expand_tokens(tokens, &shell);
		ast = parse_tokens(tokens);
		if (ast)
		{
			print_ast(ast, 0);
			ast_free(ast);
		}
		ft_dlstclear(&tokens, free_tokens);
		free(line);
	}
	cleanup_shell(&shell);
}


Isso te permite ver a Ã¡rvore sendo montada em tempo real â€”
o que Ã© uma das melhores formas de depurar o parser.


#pipes

Perfeito â€” vou te dar um passo-a-passo completo, prÃ¡tico e direto sobre como implementar pipe/pipe.c + pipe/pipe_utils.c, cobrindo todos os casos importantes (N comandos encadeados, builtins, redireÃ§Ãµes, heredoc, erros, wait, exit status).
Vou explicar a lÃ³gica, mostrar pseudocÃ³digo e trechos de C pequenos e claros que vocÃª pode copiar, dividir e adaptar ao teu estilo (e depois refatorar para a norma).

Vou supor que:

vocÃª tem uma AST onde um nÃ³ NODE_PIPE tem left e right (cada um pode ser pipe, comando, subshell, etc.);

hÃ¡ uma funÃ§Ã£o execute_ast(node, shell) que jÃ¡ sabe despachar para exec_pipeline() quando encontra NODE_PIPE;

cada nÃ³ comando contÃ©m argv, redirs (separado), etc.;

builtins sem pipe sÃ£o executados no processo pai; builtins dentro de pipeline devem ser executados em filho.

ğŸ”‘ PrincÃ­pios chave (resumo rÃ¡pido)

Para k comandos encadeados (cmd1 | cmd2 | ... | cmdk) vocÃª precisa de k-1 pipes (cada pipe = 2 fds).

Cada comando serÃ¡ executado em um processo (fork) â€” exceto builtins isolados sem pipe (executados no processo pai).

Cada processo deve ajustar sua entrada/saÃ­da com dup2() para ler do pipe anterior e escrever no pipe prÃ³ximo.

Fechar todos os fds no pai (e nos filhos quando nÃ£o forem usados) Ã© crÃ­tico.

Tratar heredoc antes de criar processos (ou criar pipes com conteÃºdo jÃ¡ pronto).

Coletar PIDs e waitpid() por todos os filhos; definir shell->exit_status conforme WIFEXITED / WIFSIGNALED.

Em caso de erro (fork/pipe), fechar fds e aguardar filhos jÃ¡ criados.

ğŸ§­ Algoritmo geral (pipeline com N comandos)

Determinar n = nÃºmero de comandos na pipeline (se tens NODE_PIPE recursivo, extrair lista linear de comandos).

Criar um array pipes[(n - 1) * 2] ou alocar dinamicamente int (*pipes)[2] = malloc((n-1) * sizeof(int[2]));
â€” cada pipe tem pipes[i][0] (read) e pipes[i][1] (write).

Para i = 0 .. n-2: pipe(pipes[i]), checar erro.

Para cada comando i = 0 .. n-1:

pid = fork().

No filho:

Se i > 0: dup2(pipes[i-1][0], STDIN_FILENO) â€” conecta leitura do pipe anterior.

If i < n-1: dup2(pipes[i][1], STDOUT_FILENO) â€” conecta escrita para prÃ³ximo.

Fechar todos pipes[*][0] e pipes[*][1] (fechar recursos duplicados).

Aplicar redirecionamentos do prÃ³prio comando (apply_redirections(...)) antes do execve.

Se for builtin: chamar implementaÃ§Ã£o do builtin e exit(status).

Se for comando externo: localizar path e execve(path, argv, envp).

No pai:

armazenar pid no vetor pids[i].

depois do fork, fechar os extremos do pipe que o pai nÃ£o mais precisa:

se i > 0: fechar pipes[i-1][0] e pipes[i-1][1]? cuidado: o pai sÃ³ fecha as extremidades que nÃ£o serÃ£o mais usadas â€” geralmente fecha pipes[i-1][0] apÃ³s criar o filho i (mas seguir padrÃ£o abaixo).

Depois de criar todos filhos: fechar todos pipes no pai.

waitpid() para cada PID e processar status, atualizar shell->exit_status com o status do Ãºltimo comando da pipeline (comportamento padrÃ£o do bash).

Retornar shell->exit_status.

ğŸ’¡ EstratÃ©gia prÃ¡tica para fechar fds (padrÃ£o seguro)

Uma tÃ©cnica simples e segura:

Crie todos os pipes primeiro (for i in 0..n-2: pipe(pipes[i])).

No loop de criaÃ§Ã£o de filhos:

No filho: dup2 conforme necessÃ¡rio; depois feche todos os pipes (loop por j=0..n-2: close(pipes[j][0]); close(pipes[j][1]);) â€” assim o filho nÃ£o mantÃ©m FDs extras.

No pai: apÃ³s o fork do filho i, nÃ£o feche imediatamente os pipes que o prÃ³ximo filho ainda possa usar; vocÃª pode fechar pipes[i-1][0] depois de criar o filho i (ou simplesmente fechar todos os pipes apenas depois do loop de forks). Fechar todos de uma vez no final Ã© mais simples e menos propenso a erro.

Recomendo: feche todos pipes apenas no final do loop (apÃ³s todos os forks) no pai â€” isso simplifica e Ã© seguro.

ObservaÃ§Ã£o de performance: fechar logo que nÃ£o precisa pode liberar recursos antes, mas para nossa implementaÃ§Ã£o a simplicidade vence.

ğŸ§© Extra: Como extrair a lista linear de comandos da AST

Se o AST representa PIPE como binÃ¡rio (left/right), transforme em vetor:

void	collect_pipeline_commands(t_ast *node, t_ast **cmds, int *count)
{
	if (node->type == NODE_PIPE)
	{
		collect_pipeline_commands(node->left, cmds, count);
		collect_pipeline_commands(node->right, cmds, count);
	}
	else
	{
		cmds[(*count)++] = node;
	}
}


Antes chame int n = count_pipeline_nodes(root); cmds = malloc(n * sizeof(t_ast*)); *count=0; collect_pipeline_commands(root, cmds, count);

Isso te dÃ¡ cmds[0..n-1].

ğŸ§¾ CÃ³digo exemplo (trechos pequenos, 3 funÃ§Ãµes principais)

Vou te dar trechos curtos, fÃ¡ceis de dividir em vÃ¡rias funÃ§Ãµes menores (Norminette friendly). VocÃª pode distribuir entre pipe.c e pipe_utils.c.

helper: criar pipes
/* pipe_utils.c */
int	**alloc_pipes(int n_pipes)
{
	int **pipes;
	int i;

	pipes = malloc(sizeof(int *) * n_pipes);
	if (!pipes) return (NULL);
	i = 0;
	while (i < n_pipes)
	{
		pipes[i] = malloc(sizeof(int) * 2);
		if (!pipes[i])
		{
			while (--i >= 0) free(pipes[i]);
			free(pipes);
			return (NULL);
		}
		if (pipe(pipes[i]) == -1)
		{
			perror("pipe");
			// limpar jÃ¡ alocados
			for (int j = 0; j <= i; ++j) { free(pipes[j]); }
			free(pipes);
			return (NULL);
		}
		i++;
	}
	return (pipes);
}


(Nota: vocÃª pode preferir int *pipes = malloc(sizeof(int) * 2 * n_pipes) para linearizar, Ã© mais compacto.)

spawn and setup (filho)
/* pipe.c (funÃ§Ã£o chamada para cada comando) */
void	child_setup_and_exec(t_ast *cmd, int i, int n, int **pipes, t_shell *shell)
{
	/* conectar stdin */
	if (i > 0)
	{
		dup2(pipes[i-1][0], STDIN_FILENO);
	}
	/* conectar stdout */
	if (i < n - 1)
	{
		dup2(pipes[i][1], STDOUT_FILENO);
	}
	/* fechar todos os pipes (filho) */
	for (int j = 0; j < n - 1; ++j)
	{
		close(pipes[j][0]);
		close(pipes[j][1]);
	}
	/* aplicar redireÃ§Ãµes do comando (se houver) */
	apply_redirections(cmd->redirs, shell);
	/* executar builtin ou externo */
	if (is_builtin(cmd))
	{
		int code = exec_builtin_child(cmd, shell); // implemente uma versÃ£o que retorna e exit
		exit(code);
	}
	/* exec externo */
	char *path = find_command_path(cmd->argv[0], shell);
	if (!path)
	{
		ft_dprintf(2, "minishell: %s: command not found\n", cmd->argv[0]);
		exit(127);
	}
	execve(path, cmd->argv, shell->envp);
	perror("execve");
	exit(126);
}

coordenador (pai)
/* pipe.c */
int run_pipe(t_ast **cmds, int n, t_shell *shell)
{
	int **pipes = alloc_pipes(n - 1);
	pid_t *pids = malloc(sizeof(pid_t) * n);
	if (!pipes || !pids) { /* liberar e retornar erro */ }

	for (int i = 0; i < n; ++i)
	{
		pids[i] = fork();
		if (pids[i] < 0)
		{
			perror("fork");
			// fechar pipes e esperar filhos jÃ¡ criados
			// ... cleanup ...
			return (1);
		}
		if (pids[i] == 0)
			child_setup_and_exec(cmds[i], i, n, pipes, shell);
		/* pai continua o loop */
	}

	/* pai fecha todos os pipes */
	for (int j = 0; j < n - 1; ++j)
	{
		close(pipes[j][0]);
		close(pipes[j][1]);
		free(pipes[j]);
	}
	free(pipes);

	/* esperar todos filhos e usar o status do Ãºltimo */
	int status;
	for (int i = 0; i < n; ++i)
	{
		waitpid(pids[i], &status, 0);
	}
	free(pids);

	if (WIFEXITED(status))
		shell->exit_status = WEXITSTATUS(status);
	else if (WIFSIGNALED(status))
		shell->exit_status = 128 + WTERMSIG(status);

	return (shell->exit_status);
}


ObservaÃ§Ãµes:

Eu deixei alguns aspectos de tratamento de erro e liberaÃ§Ã£o mÃ­nimos; quando implementar, garanta liberar pids e pipes em caso de erro no meio do loop (por exemplo, se fork() falha em i=k, aguarde pids[0..k-1] antes de retornar).

exec_builtin_child Ã© a versÃ£o do builtin que roda em filho (ela nÃ£o deve tentar manipular shell->env_list global de forma insegura; pode retornar cÃ³digo e sair).

apply_redirections() deve ser chamada antes de execve. Se redir criar erro (ex: open falhou), o filho deve exit com status apropriado.

âœ³ï¸ Casos especiais e detalhes finos
Heredoc (<<)

Gere o conteÃºdo do heredoc antes de fork (no pai) e coloque-o num pipe ou num ficheiro temporÃ¡rio.

Em seguida, o processo que precisa ler do heredoc dup2() o fd de leitura desse pipe/arquivo para STDIN.

Cuidado com sinalizaÃ§Ã£o: Ctrl+C durante leitura de heredoc deve interromper heredoc e retornar ao prompt.

Builtins dentro de pipeline

Se builtin aparece em pipeline, execute em filho (como mostrado).

Se builtin aparece sozinho (nÃ£o estÃ¡ num pipe), execute no pai para alterar o estado do shell (ex: cd muda diretÃ³rio do processo atual).

Atualizar shell->exit_status

Para pipeline, shell deve refletir o status do Ãºltimo comando da pipeline.

Para AND/OR handler, avalie os status conforme lÃ³gica.

Tratamento de sinais

Ao criar filhos, considere restabelecer comportamento padrÃ£o de sinais no filho (signal(SIGINT, SIG_DFL)) para que Ctrl+C mate o filho, nÃ£o o shell (esse detalhe Ã© importante).

SeguranÃ§a/robustez

Sempre checar retornos de pipe(), fork(), dup2(), open().

Nunca deixe descriptors abertos indesejadamente (fuga de FD).

âœ… Lista de funÃ§Ãµes que sugiro criar e onde colocÃ¡-las

pipe/pipe.c

int run_pipe(t_ast **cmds, int n, t_shell *shell);

void child_setup_and_exec(t_ast *cmd, int i, int n, int **pipes, t_shell *shell);

pipe/pipe_utils.c

int **alloc_pipes(int n_pipes);

void free_pipes(int **pipes, int n_pipes);

int *alloc_pids(int n); (ou pid_t *alloc_pids(...))

void close_all_pipes(int **pipes, int n_pipes);

exec_pipeline.c (handler)

int exec_pipeline(t_ast *node, t_shell *shell) â†’ converte AST em cmds[] e chama run_pipe(cmds, n, shell).

âœ… Checklist de testes (faÃ§a um por um)

echo a | wc -c

printf "x\n" | cat -n

ls | grep .c | wc -l

cat < infile | grep foo > outfile

echo a | (sed ... ) â€” testando subshell no pipeline

builtin in pipeline (echo): echo hello | wc -c

big pipeline 10 comandos â€” monitore FDs e uso de memÃ³ria

Ctrl+C em pipeline â€” filhos devem receber sinal, shell continua.

